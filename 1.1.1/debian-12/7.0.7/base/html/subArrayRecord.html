<html><head><title>Sub-Array Record (subArray)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="style.css">

</head>
<body class='pod'>
<!--
  generated by EPICS::PodHtml v,
  using Pod::Simple::PullParser v3.43,
  under Perl v5.036000 at Wed May 14 07:37:48 2025 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to EPICS::PodHtml, and/or subclassing EPICS::PodHtml,
   then reconverting this document from the Pod source.
   When in doubt, email the author of EPICS::PodHtml for advice.
   See 'perldoc EPICS::PodHtml' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>
<div class="pod">


<h1><a class='u'
name="Sub-Array-Record-subArray"
>Sub-Array Record (subArray)</a></h1>

<p>The normal use for the subArray record type is to obtain sub-arrays from waveform records.
Setting either the number of elements (NELM) or index (INDX) fields causes the record to be processed anew so that applications in which the length and position of a sub-array in a waveform record vary dynamically can be implemented using standard EPICS operator interface tools.</p>

<p>The first element of the sub-array,
that at location INDX in the referenced waveform record,
can be displayed as a scalar,
or the entire subarray (of length NELM) can be displayed in the same way as a waveform record.
If there are fewer than NELM elements in the referenced waveform after the INDX,
only the number of elements actually available are returned,
and the number of elements read field (NORD) is set to reflect this.
This record type does not support writing new values into waveform records.</p>

<h2><a class='u'
name="Parameter-Fields"
>Parameter Fields</a></h2>

<p>The record-specific fields are described below,
grouped by functionality.</p>

<h3><a class='u'
name="Scan-Parameters"
>Scan Parameters</a></h3>

<p>The subArray record has the standard fields for specifying under what circumstances the record will be processed.
These fields are listed in <a href="dbCommonRecord.html#Scan-Fields" class="podlinkpod"
>Scan Fields</a>.</p>

<h3><a class='u'
name="Read-Parameters"
>Read Parameters</a></h3>

<p>The subArray&#39;s input link (INP) should be configured to reference the Waveform record.
It should specify the VAL field of a Waveform record.
The INP field can be a channel access link,
in addition to a database link.</p>

<p>In addition,
the DTYP field must specify a device support module.
Currently,
the only device support module is <code>Soft Channel</code>.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">INP</td><td class="cell">Input Specification</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">DTYP</td><td class="cell">Device Type</td><td class="cell">DEVICE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Array-Parameters"
>Array Parameters</a></h3>

<p>These parameters determine the number of array elements (the array length) and the data type of those elements.
The Field Type of Value (FTVL) field determines the data type of the array.</p>

<p>The user specifies the maximum number of elements that can be read into the subarray in the MALM field.
This number should normally be equal to the number of elements of the Waveform array (found in the Waveform&#39;s NELM field).
The MALM field is used to allocate memory.
The subArray&#39;s Number of Elements (NELM) field is where the user specifies the actual number of elements that the subArray will extract.
It should of course be no greater than MALM; if it is,
the record processing routine sets it equal to MALM.</p>

<p>The INDX field determines the offset of the subArray record&#39;s array in relation to the Waveform&#39;s.
For instance,
if INDX is 2,
then the subArray will read NELM elements starting with the third element of the Waveform&#39;s array.
Thus,
it equals the index number of the Waveform&#39;s array.</p>

<p>The actual sub-array is referenced by the VAL field.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">FTVL</td><td class="cell">Field Type of Value</td><td class="cell">MENU (<a href='menuFtype.html'>menuFtype</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">VAL</td><td class="cell">Value</td><td class="cell">Set by FTVL</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">MALM</td><td class="cell">Maximum Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NELM</td><td class="cell">Number of Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">INDX</td><td class="cell">Substring Index</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

</table></blockquote>


<h3><a class='u'
name="Operator-Display-Parameters"
>Operator Display Parameters</a></h3>

<p>These parameters are used to present meaningful data to the operator.
They display the value and other parameters of the subarray record either textually or graphically.</p>

<p>EGU is a string of up to 16 characters describing the engineering units (if any) of the values which the subArray holds.
It is retrieved by the <code>get_units()</code> record support routine.</p>

<p>The HOPR and LOPR fields set the upper and lower display limits for the sub-array elements.
Both the <code>get_graphic_double()</code> and <code>get_control_double()</code> record support routines retrieve these fields.</p>

<p>The PREC field determines the floating point precision with which to display VAL.
It is used whenever the <code>get_precision()</code> record support routine is called.</p>

<p>See <a href="dbCommonRecord.html#Operator-Display-Parameters" class="podlinkpod"
>Fields Common to All Record Types</a> for more on the record name (NAME) and description (DESC) fields.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">EGU</td><td class="cell">Engineering Units</td><td class="cell">STRING [16]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">HOPR</td><td class="cell">High Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">LOPR</td><td class="cell">Low Operating Range</td><td class="cell">DOUBLE</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">PREC</td><td class="cell">Display Precision</td><td class="cell">SHORT</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">NAME</td><td class="cell">Record Name</td><td class="cell">STRING [61]</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DESC</td><td class="cell">Descriptor</td><td class="cell">STRING [41]</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Alarm-Parameters"
>Alarm Parameters</a></h3>

<p>The subarray record has the alarm parameters common to all record types.
<a href="dbCommonRecord.html#Alarm-Fields" class="podlinkpod"
>Alarm Fields</a> lists the fields related to alarms that are common to all record types.</p>

<h3><a class='u'
name="Run-time-Parameters"
>Run-time Parameters</a></h3>

<p>These fields are not configurable by the user.
They are used for the record&#39;s internal processing or to represent the current state of the record.</p>

<p>The NORD field holds the number of elements that were actually read into the array.
It will be less than NELM whenever the sum of the NELM and INDX fields exceeds the number of existing elements found in the source array.</p>

<p>BPTR contains a pointer to the record&#39;s array.</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">NORD</td><td class="cell">Number elements read</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">BPTR</td><td class="cell">Buffer Pointer</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>

<br>
<hr>
<br>


<h2><a class='u'
name="Record-Support"
>Record Support</a></h2>

<h3><a class='u'
name="Record-Support-Routines"
>Record Support Routines</a></h3>

<h4><a class='u'
name="init_record"
>init_record</a></h4>

<pre>  long (*init_record)(struct dbCommon *precord, int pass)</pre>

<p>Using MALM and FTVL, space for the array is allocated. The array address is stored in BPTR. This routine checks to see that device support is available and a device support read routine is defined. If either does not exist, an error message is issued and processing is terminated. If device support includes <code>init_record()</code>, it is called.</p>

<h4><a class='u'
name="process"
>process</a></h4>

<pre>  long (*process)(struct dbCommon *precord)</pre>

<p>See <a href="#Record-Processing" class="podlinkpod"
>&#34;Record Processing&#34;</a>.</p>

<h4><a class='u'
name="cvt_dbaddr"
>cvt_dbaddr</a></h4>

<pre>  long (*cvt_dbaddr)(struct dbAddr *paddr)</pre>

<p>This is called by <code>dbNameToAddr()</code>. It makes the dbAddr structure refer to the actual buffer holding the result.</p>

<h4><a class='u'
name="get_array_info"
>get_array_info</a></h4>

<pre>  long (*get_array_info)(struct dbAddr *paddr, long *no_elements, long *offset)</pre>

<p>Retrieves NORD.</p>

<h4><a class='u'
name="put_array_info"
>put_array_info</a></h4>

<pre>  long (*put_array_info)(struct dbAddr *paddr, long nNew)</pre>

<p>Sets NORD.</p>

<h4><a class='u'
name="get_graphic_double"
>get_graphic_double</a></h4>

<pre>  long (*get_graphic_double)(struct dbAddr *paddr, struct dbr_grDouble *p)</pre>

<p>For the elements in the array, this routine routines HOPR and LOPR. For the INDX field, this routine returns MALM - 1 and 0. For NELM, it returns MALM and 1. For other fields, it calls <code>recGblGetGraphicDouble()</code>.</p>

<h4><a class='u'
name="get_control_double"
>get_control_double</a></h4>

<pre>  long (*get_control_double)(struct dbAddr *paddr, struct dbr_ctrlDouble *p)</pre>

<p>For array elements, this routine retrieves HOPR and LOPR. Otherwise, <code>recGblGetControlDouble()</code> is called.</p>

<h4><a class='u'
name="get_units"
>get_units</a></h4>

<pre>  long (*get_units)(struct dbAddr *paddr, char *units)</pre>

<p>Retrieves EGU.</p>

<h4><a class='u'
name="get_precision"
>get_precision</a></h4>

<pre>  long (*get_precision)(const struct dbAddr *paddr, long *precision)</pre>

<p>Retrieves PREC.</p>

<h3><a class='u'
name="Record-Processing"
>Record Processing</a></h3>

<p>Routine process implements the following algorithm:</p>

<ol>
<li>Check to see that the appropriate device support module exists. If it doesn&#39;t, an error message is issued and processing is terminated with the PACT field still set to TRUE. This ensures that processes will no longer be called for this record. Thus error storms will not occur.</li>

<li>Sanity check NELM and INDX. If NELM is greater than MALM it is set to MALM. If INDX is greater than or equal to MALM it is set to MALM-1.</li>

<li>Call the device support&#39;s <code>read_sa()</code> routine. This routine is expected to place the desired sub-array at the beginning of the buffer and set NORD to the number of elements of the sub-array that were read.</li>

<li>If PACT has been changed to TRUE, the device support read operation has started but has not completed writing the new value. In this case, the processing routine merely returns, leaving PACT TRUE. Otherwise, process sets PACT TRUE at this time. This asynchronous processing logic is not currently used but has been left in place.</li>

<li>Check to see if monitors should be invoked.
<ul>
<li>Alarm monitors are invoked if the alarm status or severity has changed.</li>

<li>Archive and value change monitors are always invoked.</li>

<li>NSEV and NSTA are reset to 0.</li>
</ul>
</li>

<li>Scan forward link if necessary, set PACT FALSE, and return.</li>
</ol>
<br>
<hr>
<br>


<h2><a class='u'
name="Device-Support"
>Device Support</a></h2>

<h3><a class='u'
name="Fields-Of-Interest-To-Device-Support"
>Fields Of Interest To Device Support</a></h3>

<p>The device support routines are primarily interested in the following fields:</p>
<blockquote><table border="1"><tr>
<th>Field</th><th>Summary</th><th>Type</th><th>DCT</th>
<th>Default</th><th>Read</th><th>Write</th><th>CA PP</th>
</tr>
<tr><td class="cell">PACT</td><td class="cell">Record active</td><td class="cell">UCHAR</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">DPVT</td><td class="cell">Device Private</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">UDF</td><td class="cell">Undefined</td><td class="cell">UCHAR</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">NSEV</td><td class="cell">New Alarm Severity</td><td class="cell">MENU (<a href='menuAlarmSevr.html'>menuAlarmSevr</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NSTA</td><td class="cell">New Alarm Status</td><td class="cell">MENU (<a href='menuAlarmStat.html'>menuAlarmStat</a>)</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">INP</td><td class="cell">Input Specification</td><td class="cell">INLINK</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">No</td></tr>

<tr><td class="cell">FTVL</td><td class="cell">Field Type of Value</td><td class="cell">MENU (<a href='menuFtype.html'>menuFtype</a>)</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">MALM</td><td class="cell">Maximum Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NELM</td><td class="cell">Number of Elements</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">1</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">INDX</td><td class="cell">Substring Index</td><td class="cell">ULONG</td><td class="cell">Yes</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">Yes</td><td class="cell">Yes</td></tr>

<tr><td class="cell">BPTR</td><td class="cell">Buffer Pointer</td><td class="cell">NOACCESS</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">No</td><td class="cell">No</td><td class="cell">No</td></tr>

<tr><td class="cell">NORD</td><td class="cell">Number elements read</td><td class="cell">LONG</td><td class="cell">No</td><td class="cell">&nbsp;</td><td class="cell">Yes</td><td class="cell">No</td><td class="cell">No</td></tr>

</table></blockquote>


<h3><a class='u'
name="Device-Support-Routines-devSASoft.c"
>Device Support Routines (devSASoft.c)</a></h3>

<p>Device support consists of the following routines:</p>

<h4><a class='u'
name="long-report-int-level"
>long report(int level)</a></h4>

<p>This optional routine is called by the IOC command <code>dbior</code> and is passed the report level that was requested by the user. It should print a report on the state of the device support to stdout. The <code>level</code> parameter may be used to output increasingly more detailed information at higher levels, or to select different types of information with different levels. Level zero should print no more than a small summary.</p>

<h4><a class='u'
name="long-init-int-after"
>long init(int after)</a></h4>

<p>This optional routine is called twice at IOC initialization time. The first call happens before any of the <code>init_record()</code> calls are made, with the integer parameter <code>after</code> set to 0. The second call happens after all of the <code>init_record()</code> calls have been made, with <code>after</code> set to 1.</p>

<h4><a class='u'
name="init_record"
>init_record</a></h4>

<pre>  long init_record(subArrayRecord *prec)</pre>

<p>This routine is called by the record support <code>init_record()</code> routine.</p>

<h4><a class='u'
name="read_sa"
>read_sa</a></h4>

<pre>  long read_sa(subArrayRecord *prec)</pre>

<p>Enough of the source waveform is read into BPTR, from the beginning of the source, to include the requested sub-array. The sub-array is then copied to the beginning of the buffer. NORD is set to indicate how many elements of the sub-array were acquired.</p>

<h3><a class='u'
name="Device-Support-For-Soft-Records"
>Device Support For Soft Records</a></h3>

<p>Only the device support module <code>Soft Channel</code> is currently provided.</p>

<h4><a class='u'
name="Soft-Channel"
>Soft Channel</a></h4>

<p>INP is expected to point to an array field of a waveform record or similar.</p>
</div>


<!-- end doc -->

</body></html>
